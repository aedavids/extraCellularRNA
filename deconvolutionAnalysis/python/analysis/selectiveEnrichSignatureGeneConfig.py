#
# selectiveEnrichSignatureGeneConfig.py
#
# Andrew E. Davidson
# aedavids@ucsc.edu
# ref: testSelectEnrichSignatureGeneConfig.py
#

# SelectiveEnrichSignatureGeneConfigCLI CommandLine display the doc string 
'''
    psudo code
    for degree 1 sets in --intersectionDict :
        category = deseq results file category
        results = intersectionDict [ category ]
        
        if category in list of --classes:
            search for at most items --numAdd
            add new items to resutls

        return results
'''
import logging
import os
import pandas as pd
import pprint as pp

from analysis.bestSignatureGeneConfig import BestSignatureGeneConfig
# from analysis.bestRemoveHighDegreeSignatureGeneConfig import BestRemoveHighDegreeSignatureGeneConfig
from analysis.selectiveEnrichSignatureGeneConfigCLI import SelectiveEnrichSignatureGeneConfigCLI
from analysis.utilities import  findAllGenes
from analysis.utilities import fileNameToDictKey
# from analysis.utilities import findElementsInIntersectionsWithDegree
from analysis.utilities import findSetsWithDegree
from analysis.utilities import findIntersectionsWithDegree
from analysis.utilities import loadDictionary

# global variables use by PipelineCommandLine
__all__ = []
__version__ = 0.1
__author__ = "Andrew Davidson aedavids@ucsc.edu"
__date__ = '2023-12-26'
__updated__ = '2023-12-26'

################################################################################
class SelectiveEnrichSignatureGeneConfig( BestSignatureGeneConfig  ):
    '''
    TODO

    add items to a select list of categories
    '''

    logger = logging.getLogger(__name__)

    ################################################################################
    def __init__(self, 
                    dataSetName : str, 
                    design : str, 
                    padjThreshold : float, 
                    lfcThreshold : float, 
                    n : int, 
                    localCacheRootPath : str, 
                    title : str,
                    intersectionDictionaryPath : str,
                    numberOfGenesToAdd : int,
                    categories : list[str],
                    ) :
        super().__init__(
                    dataSetName=dataSetName,
                    design=design,
                    padjThreshold=padjThreshold,
                    lfcThreshold=lfcThreshold,
                    n=n,
                    localCacheRootPath=localCacheRootPath,
                    title=title,
        )
        '''
        TODO

        ensures each category in categories has at least numberOfGenesToAdd degree 1 genes

        arguments:
            numberOfGenesToAdd: 
                TODO AEDWIP bad name. Ensure each degree1 intersection has at least numberOfGenesToAdd elements

            intersectionDictionaryPath : str
                output from upstream stage of pipeilne. A dictionary key is multi-index identifying sets 
                that share elements. Value is the list of shared elements. 

                format example: ./analysis/test/data/intersection.dict

                see plots.test.testUpsetPlots testIntersection()

        '''

        self.intersectionDictionaryPath = intersectionDictionaryPath
        self.numberOfGenesToAdd = numberOfGenesToAdd
        self.categories = categories

        # with open(self.intersectionDictionaryPath) as f: 
        #     data = f.read() 

        # # we can not convert the intersectionData to a DataFrame
        # # the size of the interesections is not constant. 
        # # we would need to pad the dictionary values
        # self.intersectionDict = ast.literal_eval(data)

        self.intersectionDict  = loadDictionary(self.intersectionDictionaryPath )

        # keep track of all genes we add accross all fileName
        # key: fileName, value = deseq results for gene
        # use dictionary to make it easy to create log entry
        self.addGenesDict = dict()

        # fast way to test candidate genes for uniqueness
        self.addGenesSet = set()

        self.degree1IntersectionDict = findIntersectionsWithDegree(self.intersectionDict, degree=1)

        # intersectionDict is typically generated by upset plot
        # part of a our pipeline. This is from a previous pipeline run.
        # The plot run after signature gene selection
        self.degree1Sets = findSetsWithDegree(self.intersectionDict, 1)

        self.globalGenes = findAllGenes(self.intersectionDict)

    ################################################################################
    def findGenes(self, deseqDF : pd.DataFrame, fileName : str ) -> pd.DataFrame :
        '''
        psudo code
        for degree 1 sets in --intersectionDict :
            category = deseq results file category
            results = intersectionDict [ category ]
            
            if category in list of --classes:
                search for at most items --numAdd
                add new items to resutls

            return results       

        ref: analysis.test.testEnrichSignatureGeneConfig
        '''
        self.logger.info("BEGIN")

        # sortedDF all genes with lcf2 > threshold and padj < threshold, sorted by base mean
        sortedDF = self._select(deseqDF, fileName)

        # we want to be able to use iloc to iterate over the rows
        # copy the sorted index to a new column named rank
        # assign a new index from 0 ... num rows -1
        sortedDF = sortedDF.reset_index(names="orginalIdx")

        genesToAddDF = pd.DataFrame()
        category = fileName.removesuffix( "_vs_all.results" )
        key = fileNameToDictKey(fileName)

        uniqueGenes = []
        if not category in self.degree1Sets:
            self.logger.warning(f'category : {category} not in degree1Set {self.degree1Sets}')
            return pd.DataFrame()
        
        elif not category in self.categories:
            self.logger.warning(f' category : {category} is not in categories :{self.categories}')
            genes = self.degree1IntersectionDict[key]
            selectRows = deseqDF.loc[:, "name"].isin(genes)
            retDF = deseqDF.loc[selectRows, :]
            return retDF
      
        else :
            # the keys of the intersection dictionary are tuples
            # degree1 keys are of form ('Vagina',) weird
            uniqueGenes = self.degree1IntersectionDict[key]

        uniqueGenesResultsDF = self._selectDegree1DESeqResults(deseqDF, uniqueGenes)
        # default return
        retDF = uniqueGenesResultsDF

        self.logger.info(f'BEGIN category: {category} uniqueGenes : {uniqueGenes}')

        startSearchIdx = self._findStartSearchIdx(sortedDF, uniqueGenes, category)

        localAddGenes = self._findAdditions(startSearchIdx,sortedDF, category)

        if len(localAddGenes) > 0:
            localUniqueGenesResultsDF = self._selectLocalUniqueGenesDESeqResults(category, deseqDF, sortedDF, localAddGenes)
            self.logger.debug(f'category : {category} add \n{pp.pformat(localUniqueGenesResultsDF)}')
            retDF = pd.concat( [uniqueGenesResultsDF, localUniqueGenesResultsDF])
        else:
            self.logger.info(f'category : {category} was not enriched len(uniqueGenes): {len(uniqueGenes)} >= self.numberOfGenesToAdd :{self.numberOfGenesToAdd}')
     
        self.logger.info("END")
        return retDF


    ################################################################################
    def __del__(self):
        '''
        __del__ like a C++ destructor
        '''
        self.logger.info(f'BEGIN')

        self.logger.info(f'number of genes that will be added to signature matrix: {len(self.addGenesSet)}')
        self.logger.info(f'genes that will be added to signature matrix\n{self.addGenesSet}')
        self.logger.info(f'addGenesDict: \n{pp.pformat(self.addGenesDict, indent=4, sort_dicts=True)}')

        self.logger.info(f'END')

    ################################################################################
    def _findAdditions(
            self,
            startSearchIdx : int,
            sortedDF : pd.DataFrame,
            category : str
            ) -> list[str] :
        '''
        TODO AEDWIP
        '''
        self.logger.info(f'BEGIN')
        retAddedGenes = []
        numAdditions = 0
        for i in range(startSearchIdx, sortedDF.shape[0]):
            if numAdditions >= self.numberOfGenesToAdd:
                break

            candidateRowSeries = sortedDF.iloc[i, :]
            candidateName = candidateRowSeries.loc["name"]
            self.logger.info(f'AEDWIP category: {category}  candidateName : {candidateName} ')

            if candidateName not in self.addGenesSet:
                # if candidateName not in self.upstreamDegree1GeneSet: aedwip this should be all. Not going to work, we reduced
                if candidateName not in self.globalGenes: 
                    # we found a unique gene
                    # add to list of global additions
                    self.addGenesSet.add( candidateName )

                    # add to list of local addition
                    retAddedGenes.append( candidateName )

                    numAdditions = numAdditions + 1
                    self.logger.info(f'AEDWIP change to debug category: {category}  numAdditions : {numAdditions} added : {candidateName}')

        self.logger.info(f'category : {category} completed search. i : {i} len(retAddedGenes) : {len(retAddedGenes)}')

        self.logger.info(f'END')
        return retAddedGenes
    
    ################################################################################
    def _selectDegree1DESeqResults(self,
                                        deseqDF : pd.DataFrame,
                                        uniqueGenes : list[str],
                                        ) -> pd.DataFrame :
        '''
        TODO
        '''
        self.logger.info("BEGIN")

        selectRows = deseqDF.loc[:, "name"].isin(uniqueGenes)
        retDF = deseqDF.loc[selectRows, :]

        self.logger.info("END")
        return retDF
    
    ################################################################################
    def _findStartSearchIdx(self,
                            sortedDF : pd.DataFrame,
                            uniqueGenes : list[str],
                            category : str,
                            ) -> int :
        '''
        figure out where to start search for candidates
        potential items have been sorted, removed or added by upstream pipeline stages
        The change will vary by category
        try to identify the "weakest", "poorest" item for category using
        it sorted row/rank idx
        '''
        self.logger.info(f'BEGIN')

        selectRows = sortedDF.loc[:, "name"].isin(uniqueGenes)
        self.logger.info(f'AEDWIP selectRows: {selectRows}')

        uniqueSeries = sortedDF.loc[selectRows, "orginalIdx"]
        self.logger.info(f'AEDWIP uniqueSeries: {pp.pformat(uniqueSeries)}')

        lastOriginalIdx = uniqueSeries.max()
        startSearchIdx = uniqueSeries[ uniqueSeries == lastOriginalIdx ].index[0] + 1
        self.logger.info(f'category : {category}  startSearchIdx: {startSearchIdx}')

        self.logger.info(f'END')
        return startSearchIdx

    ################################################################################
    def _selectLocalUniqueGenesDESeqResults(self,
                                        category : str,
                                        deseqDF : pd.DataFrame,
                                        sortedDF : pd.DataFrame,
                                        localAddGenes : list[str],
                                        ) -> pd.DataFrame :
        '''
        TODO
        '''
        self.logger.info("BEGIN")

        # make down stream analysis easier
        # log ranks of additions. In future we might want to do something 
        # more clever with ranking. provide evidence for go/no go
        selectRowsWithRank = sortedDF.loc[:, "name"].isin(localAddGenes)
        rankedAdditionDF = sortedDF.loc[selectRowsWithRank, : ].sort_values(by="baseMean", ascending=False)
        self.logger.info(f'category : {category} ranked additions \n {pp.pformat(rankedAdditionDF)}')

        # use deseqDF, sortedDF has an extra column.
        # concat will not work with extra column
        selectRows = deseqDF.loc[:, "name"].isin(localAddGenes)
        # sort to make down stream analysis easier. Matches bestN
        uniqueGenesDF = deseqDF.loc[selectRows, : ].sort_values(by="baseMean", ascending=False)

        self.logger.info("END")
        return uniqueGenesDF

################################################################################
def main(inCommandLineArgsList=None):
    '''
    use to test parsing of vargs
    '''
    # we only configure logging in main module
    loglevel = "WARN"
    loglevel = "INFO"
    # logFMT = "%(asctime)s %(levelname)s [thr:%(threadName)s %(name)s %(funcName)s() line:%(lineno)s] [%(message)s]"
    logFMT = "%(asctime)s %(levelname)s %(name)s %(funcName)s() line:%(lineno)s] [%(message)s]"
    logging.basicConfig(format=logFMT, level=loglevel)    

    logger = logging.getLogger(os.path.basename(__file__))
    logger.warning("BEGIN")

    #
    # always log run time env to make debug easier
    #
    ORIG_PYTHONPATH = os.environ['PYTHONPATH']
    logger.warning(f'PYTHONPATH : {ORIG_PYTHONPATH}')
    logger.warning(f'FILE: {__file__}')
    logger.warning(f'PWD: {os.getcwd()}')

    cli = SelectiveEnrichSignatureGeneConfigCLI(version="testVersion" , 
                            author="testAuthor",
                            date="testDate", 
                            update="testUpdate")
    
    if inCommandLineArgsList is None:
        cli.parse()
    else:
        cli.parse( inCommandLineArgsList )

    logger.warning(f'command line arguments : {cli.args}')

    design          = cli.args.design 
    logger.info(f'design : {design}')

    padjThreshold   = cli.args.padjThreshold
    logger.info(f'padjThreshold : {padjThreshold}')

    lfcThreshold    = cli.args.lfcThreshold
    logger.info(f'lfcThreshold : {lfcThreshold}')

    dataSetName     = cli.args.dataSetName
    logger.info(f'dataSetName : {dataSetName}')

    number          = cli.args.number
    logger.info(f'number : {number}')

    title           = cli.args.title
    logger.info(f'title : {title}')

    localCacheRoot  = cli.args.localCacheRoot
    logger.info(f'localCacheRoot : {localCacheRoot}')

    intersectionDictPath = cli.args.intersectionDict
    logger.info(f'intersectionDictPath : {intersectionDictPath}')

    numAdd           = cli.args.numAdd
    logger.info(f'numAdd : {numAdd}')

    # do not use variable name that are close to python key works
    categories       = cli.args.classes
    logger.info(f'categories : {categories}')

    logger.warning(f'END')

################################################################################
if __name__ == '__main__':
    '''
    hack used to test parsing of vargs
    '''
    main( 
        # inCommandLineArgsList=["--design", "tilda_gender_category",
        #                          "--padjThreshold", "0.001",
        #                          "--lfcThreshold", "2.0",
        #                          "--dataSetName", "GTEx_TCGA",
        #                          "--number" , "10",
        #                          "--title", "a vs all",
        #                          "--localCacheRoot", "myCacheRoot",
        #                          "--intersectionDict", "./analysis/test/data/intersection.dict",
        #                         #  "--degreeThreshold", "5",
        #                         #"--numUnique", "3"
        #                         "--classes", "classAAA classBBB",
        #                         "--numAdd", "3",
        #                         # "--UnexpectedArgument",
        #                         ]

            inCommandLineArgsList=["--help"]                
        )




